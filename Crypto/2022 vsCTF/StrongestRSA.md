# StrongestRSA

## files

### chall.py

```python
from Crypto.Util.number import getStrongPrime, bytes_to_long
from sympy import prevprime, factorial
from math import gcd
import random

from secret import FLAG

e = 0x10001

def getStrongestPrime(nbits):
    while True:
        p = getStrongPrime(nbits)
        delta = random.randint(0x1337, 0x1337 + 0x1337)
        pp = p - delta
        ppp = prevprime(factorial(pp) % p)
        if gcd(ppp-1, e) == 1:
            return p, ppp
    
NBITS = 1024
p0, p = getStrongestPrime(NBITS)
q0, q = getStrongestPrime(NBITS)
N = p * q
m = bytes_to_long(FLAG.encode())
c = pow(m, e, N)

print(f"p0 = {p0}\nq0 = {q0}")
print(f"N = {N}\ne = {e}\nc = {c}")
```

### output.txt

```
p0 = 163753477176210014003355280732229891908166074468271556144642666169325605017666799921295576722168608401188682320182653287668989748162506955989407213845500704903463544753049275828138559289189335596749709834289278256382427251831790026921563375111737350084174473833546767952081017613072491759534988253353621530923
q0 = 157598184809589313845990455272198459548591786211953253450211152128535343234857067521711590445365424087430728267491317690639227988484930088637483194045435135802590588269993794073236513557034321374876808546159597997280236993358749182432517011554239468502233558179815446959403076134284375214662245037202945590183
N = 11884142558095727641000594156833818117849240126500615037738361957005811068956622520280143210434649198031005585252791693777710458190732464123269660559382653636999601459113099276826723072914352276709761755328542359490331355061792823458149611674845846523699218971126655186522340818792078719216860046464292413878045842425132308544311887062610272360069819975798905665533964761527225558339025724872067751916657135473510775709503714808686565298632040214249698116863336246844759838665285888816202570667521796553678688293761589082062045634768520102235077364345013564344229095323239077977717497503322831684471959195555281580807
e = 65537
c = 11776079752956619284016871274992903352398310565005810097721997339193718454945819135683541554652454321040530044545154341786048659896370226535387839157317585368391189570502841702311449000698372030666509296004039398083488490698999338894328619127149024309470011330855840757405205104944658961386764569043610715311746676861275270073394069269043429092551681704290340091149637137627751767730812255069347108706434972786681985484368054390699974613090342753508097177008167140924577095976699437810398922852319420301082587264411993737330188227703869101718515748828944300463051133118636928879090217708121368293440440444106196607645
```

## Solution

given value is p0, q0. but n is p * q, p is calculated by p0, and the same goes for value q and q0

Random integer delta is value between 0x1337 and 0x266e. hex value 0x1337 is 4919 so we can guess delta value by brute forcing

Note that getStrongestPrime function. there is a factorial function, but we should use that with very big value p0 and q0. this caculation is repeated so many times if we brute forcing it.

I don't know why this `factorial(pp) % p` code working correct when create p0 and q0. by the way, we should edit this code in our own way and it would be good to have less time complexity.

We can use Willson's theorem when calculate modular arithmetic with factorial.

if we there's a prime p and p is bigger than 2 :

`(p-1)! ≡ -1(mod p)`

if we has value p0, and caculate p subtract delta(δ) from p0 value, we can apply this theorem to this:

`(p0-δ)! ≡ -((p0-1)^-1)*((p0-2)^-1)*...*((p0-δ+1)^-1) (mod p0)`

note that each right side's value is inverse value of factor. 

delta is random value so we start with "delta value is 0x1337(min)" so we can extend brute force by this:

`(p0-δ)! ≡ -((p0-1)^-1)*((p0-2)^-1)*...*((p0-δ+1)^-1) (mod p0)`

`(p0-δ-1)! ≡ -((p0-1)^-1)*((p0-2)^-1)*...*((p0-δ+1)^-1)*((p0-δ)^-1) (mod p0)`

...

`(p0-2δ)! ≡ -((p0-1)^-1)*((p0-2)^-1)*...*((p0-2δ+1)^-1) (mod p0)`

so we can get possible p values by repeating 0x1337 * ? times and the same process goes for getting the value q.

if we get possible p and q value, compare p * q == n. and get real p and q.

## exploit

```python
from sympy import prevprime
from gmpy2 import *

e = 0x10001
p0 = 163753477176210014003355280732229891908166074468271556144642666169325605017666799921295576722168608401188682320182653287668989748162506955989407213845500704903463544753049275828138559289189335596749709834289278256382427251831790026921563375111737350084174473833546767952081017613072491759534988253353621530923
q0 = 157598184809589313845990455272198459548591786211953253450211152128535343234857067521711590445365424087430728267491317690639227988484930088637483194045435135802590588269993794073236513557034321374876808546159597997280236993358749182432517011554239468502233558179815446959403076134284375214662245037202945590183
N = 11884142558095727641000594156833818117849240126500615037738361957005811068956622520280143210434649198031005585252791693777710458190732464123269660559382653636999601459113099276826723072914352276709761755328542359490331355061792823458149611674845846523699218971126655186522340818792078719216860046464292413878045842425132308544311887062610272360069819975798905665533964761527225558339025724872067751916657135473510775709503714808686565298632040214249698116863336246844759838665285888816202570667521796553678688293761589082062045634768520102235077364345013564344229095323239077977717497503322831684471959195555281580807
e = 65537
c = 11776079752956619284016871274992903352398310565005810097721997339193718454945819135683541554652454321040530044545154341786048659896370226535387839157317585368391189570502841702311449000698372030666509296004039398083488490698999338894328619127149024309470011330855840757405205104944658961386764569043610715311746676861275270073394069269043429092551681704290340091149637137627751767730812255069347108706434972786681985484368054390699974613090342753508097177008167140924577095976699437810398922852319420301082587264411993737330188227703869101718515748828944300463051133118636928879090217708121368293440440444106196607645

ppp = [] #get all value ppp about random value delta
qqq = []
ppp_real = [] #ppp value that satisfy gcd condition
qqq_real = []

delta = 0x1337

# get all ppp
pp = p0 - delta
fct = 1
for i in range(delta):
    fct *= invert(pp+i,p0)
    fct %= p0

fct = fct * (p0-1) %p0
ppp.append(int(fct))

for i in range(delta):
    x = invert(p0 - delta - 1 - i,p0)
    x *= ppp[i]
    x %= p0
    ppp.append(int(x))

# get all p satisfy condition
for i in range(len(ppp)):
    prev = prevprime(ppp[i])
    if (gcd(prev-1,e)==1):
        ppp_real.append(prev)

# same process about q
qq = q0 - delta
fct = 1
for i in range(delta):
    fct *= invert(qq+i,q0)
    fct %= q0

fct = fct * (q0-1) %q0
qqq.append(int(fct))

for i in range(delta):
    x = invert(q0 - delta - 1 - i,q0)
    x *= qqq[i]
    x %= q0
    qqq.append(int(x))

for i in range(len(qqq)):
    prev = prevprime(qqq[i])
    if (gcd(prev-1,e)==1):
        qqq_real.append(prev)

# get p and q
for i in qqq_real:
    for j in ppp_real:
        if i * j == N:
            q = i
            p = j
            
phi = (p-1)*(q-1)
d = invert(e,phi)
print(unhexlify(hex(powmod(c,d,N))[2:].encode()))
```

this takes some times(repeat : 4919 * 4 + α times minute: 7min) but we can finally get message:

`b'vsctf{Strongest_can_be_the_weakest:(}'`

